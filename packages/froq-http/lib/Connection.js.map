{"version":3,"sources":["../src/Connection.js"],"names":["Server","name","_name","_sockets","port","undefined","address","Promise","resolve","reject","_server","createServer","req","resp","info","method","url","_handler","_nextHandler","then","catch","error","e","stack","_errorHandler","listen","addListener","debug","push","socket","filter","sock","close","forEach","end","handler","statusCode","write"],"mappings":"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","file":"Connection.js","sourcesContent":["import http from 'http';\nimport { log } from 'froq-util';\n\nexport default class Server {\n\n    /**\n     * \n     * @param {string} name \n     */\n    constructor(name = 'server') {\n        this._name = name;\n        this._sockets = [];\n    }\n\n    /**\n     * @returns {string}\n     */\n    get name() {\n        return this._name;\n    }\n\n    /**\n     * \n     * @param {number?} port \n     * @param {string?} address \n     */\n    start(port = undefined, address = undefined) {\n        return new Promise((resolve, reject) => {\n\n            this._server = http.createServer((req, resp) => {\n                log.info(`${req.method} ${req.url}`);\n\n                if (this._handler) {\n                    this._handler(req, resp, this._nextHandler(req, resp))\n                        .then(() => {\n                            log.info(`${this._name} request ${req.url} processed.`);\n                        })\n                        .catch(e => {\n                            log.error(`${this._name} request ${req.url} error: ${e.stack}`);\n                            this._errorHandler(req, resp, e);\n                        });\n                    ;\n                }\n            });\n\n            this._server.listen(port, address, () => {\n                log.info(`${this._name} port ${this.address.port} bound.`);\n                resolve();\n            });\n\n            this._server.addListener('connection', socket => {\n                log.debug(`${this._name} new connection.`);\n                this._sockets.push(socket);\n                socket.addListener('close', () => {\n                    log.debug(`${this._name} connection close.`);\n                    this._sockets = this._sockets.filter(sock => sock !== socket);\n                });\n            });\n        });\n    }\n\n    /**\n     * @returns {string}\n     */\n    get address() {\n        return this._server.address();\n    }\n\n    stop() {\n        log.info(`${this._name} close`);\n        return new Promise((resolve, reject) => {\n            this._server.close(() => {\n                this._sockets.forEach(socket => socket.end());\n                this._sockets = [];\n\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * \n     * @param {(req, resp, next) => void} handler \n     */\n    setHandler(handler) {\n        this._handler = handler;\n    }\n\n    _nextHandler(req, resp) {\n        return async () => {\n            log.error(`could not find a suited endpoint: ${req.method} ${req.url}`);\n\n            resp.statusCode = 404;\n            resp.end();\n        };\n    }\n\n    _errorHandler(req, resp, e) {\n        resp.statusCode = 500;\n        resp.write(e.stack);\n        resp.end();\n    }\n}"]}