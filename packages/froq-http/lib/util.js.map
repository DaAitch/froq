{"version":3,"sources":["../src/util.js"],"names":["qSymbol","Symbol","resultByPlaceholders","placeholders","result","x","i","length","mimes","application","audio","example","image","message","model","multipart","text","video","isMime","test","mime","RegExp","$1","contentTypeLookupOrThrow","type","contentType","lookup","TypeError","transformRestTemplate","strings","method","undefined","$2","substring","respBodyForType","body","Buffer","isBuffer","JSON","stringify","warning","reqBodyForType","Promise","resolve","reject","chunks","req","on","push","chunk","buffer","concat","reqBufferToBody","headers","parse","toString","resp","status","defaultCompareFn","a","b","routeCompareFn","getPlaceholderCount","pathMatch","path","found","placeholder","substr","r","match","stringToFn","string","position","lastIndexOf","find","placeholderToFn","expression","Function","createPathMatcherFromTemplate","map","fn","slice","placeholderCount"],"mappings":"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","file":"util.js","sourcesContent":["import { log } from 'froq-util';\nimport { isJsonType, isTextType } from './mime';\n\nimport httpProxy from 'http-proxy';\nimport mime from 'mime-types';\n\n\nexport const qSymbol = Symbol('Q');\n\nexport const resultByPlaceholders = (placeholders, result) => {\n    const x = [...result];\n\n    for (let i = 0; i < result.length; ++i) {\n        if (typeof placeholders[i] !== 'string' || placeholders[i] in x) {\n            continue;\n        }\n\n        x[placeholders[i]] = result[i];\n    }\n\n    return x;\n};\n\n\nexport const mimes = {\n    application: true,\n    audio: true,\n    example: true,\n    image: true,\n    message: true,\n    model: true,\n    multipart: true,\n    text: true,\n    video: true\n};\n\nexport const isMime = mime => {\n    if (!/^([^/]+)\\//.test(mime)) {\n        return false;\n    }\n\n    return RegExp.$1 in mimes;\n};\n\nexport const contentTypeLookupOrThrow = type => {\n    if (isMime(type)) {\n        return type;\n    }\n\n    const contentType = mime.lookup(type);\n    if (contentType !== false) {\n        return contentType;\n    }\n\n    throw new TypeError(`unknown type: ${type}`);\n};\n\nexport const transformRestTemplate = (strings, placeholders) => {\n\n    let method = undefined;\n\n    if (strings.length >= 1 && /^(\\s*(\\S+)\\s+)\\//.test(strings[0])) {\n        method = RegExp.$2;\n        strings = [...strings];\n        strings[0] = strings[0].substring(RegExp.$1.length);\n    }\n\n    return [\n        method,\n        strings,\n        placeholders\n    ];\n};\n\nexport const respBodyForType = (type, body) => {\n\n    if (Buffer.isBuffer(body)) {\n        return body;\n    }\n\n    if (isJsonType(type)) {\n        return JSON.stringify(body);\n    }\n\n    if (isTextType(type) && typeof body === 'string') {\n        return body;\n    }\n\n    log.warning(`cannot transform body for type ${type}`);\n    if (typeof body === 'string') {\n        return body;\n    }\n\n    // any string representation\n    return `>>> ${typeof body}: ${JSON.stringify(body)}`;\n};\n\nexport const reqBodyForType = req => {\n    return new Promise((resolve, reject) => {\n        const chunks = [];\n        req\n            .on('data', chunk => {\n                chunks.push(chunk);\n            })\n            .on('end', () => {\n                const buffer = Buffer.concat(chunks);\n                resolve(reqBufferToBody(req.headers['content-type'], buffer));\n            })\n            .on('error', reject)\n        ;\n    });\n};\n\n/**\n * \n * @param {string} type \n * @param {Buffer} buffer \n */\nexport const reqBufferToBody = (type, buffer) => {\n    if (isJsonType(type)) {\n        return JSON.parse(buffer.toString());\n    }\n\n    if (isTextType(type)) {\n        return buffer.toString();\n    }\n\n    return buffer;\n};\n\nexport const resp = ({body = null, type = 'json', status = 200}) => ({\n    [qSymbol]: true,\n    body,\n    type,\n    status\n});\n\n\nexport const defaultCompareFn = (a, b) => (a < b) ? -1 : ((a > b) ? +1 : 0);\n\nexport const routeCompareFn = (a, b) => {\n    return defaultCompareFn(a.getPlaceholderCount(), b.getPlaceholderCount());\n};\n\n/**\n * \n * @param {string} path \n * @param {((path: string, index: number) => [number, number])[]} strings \n * @param {((placeholder: string) => boolean)[]} placeholders \n * @param {number} i \n * @param {any[]} result\n */\nexport const pathMatch = (path, strings, placeholders, i = 0, result = []) => {\n    \n    if (i >= placeholders.length) {\n        return result;\n    }\n\n    let found = path.length + 1;\n    let length = -1;\n\n    for (;;) {\n        [found, length] = strings[i](path, found - 1);\n        if (found < 0) {\n            return false;\n        }\n\n        const placeholder = path.substr(0, found);\n        if (!placeholders[i](placeholder)) {\n            continue;\n        }\n\n        const r = [...result];\n        r[i] = placeholder;\n        \n        const match = pathMatch(path.substr(found + length), strings, placeholders, i + 1, r);\n        if (false !== match) {\n            return match;\n        }\n    }\n};\n\n\nconst stringToFn = find => (string, position) => [string.lastIndexOf(find, position), find.length];\nconst placeholderToFn = expression => {\n    if (typeof expression === 'string') {\n        return () => true;\n    } else if (expression instanceof RegExp) {\n        return placeholder => expression.test(placeholder);\n    } else if (expression instanceof Function) {\n        return expression;\n    }\n\n    throw new TypeError(`unknown placeholder: ${expression}`);\n};\n\n/**\n * \n * @param {string[]} strings \n * @param {any[]} placeholders \n */\nexport const createPathMatcherFromTemplate = (strings, ...placeholders) => {\n\n    strings = strings.map(stringToFn);\n    placeholders = [x => x === '', ...placeholders.map(placeholderToFn)];\n\n    const fn = path => {\n        const result = pathMatch(path, strings, placeholders);\n        if (result === false) {\n            return result;\n        }\n\n        return result.slice(1);\n    };\n\n    fn.placeholderCount = placeholders.length - 1; // without x => x === ''\n\n    return fn;\n};"]}